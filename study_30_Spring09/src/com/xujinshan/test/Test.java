package com.xujinshan.test;

/**
 * 声明式事务
 * 		编程式事务：
 * 			由程序员编写事务控制代码
 * 			OpenSessionInView 编程式事务
 * 		声明式事务：
 * 			事务控制代码已经有spring写好，程序员只需要声明出那些方法需要进行事务控制和如何进行事务控制
 * 		声明式事务都是针对ServiceImpl类下的方法
 * 		事务管理器基于通知(advice)的
 * 		在spring配置文件中配置声明式事务
 * 
 * 声明式事务中属性解释
 * 		name="" 哪些方法需要有事务控制
 * 			支持* 通配符
 * 		read-only="boolean" 是否是只读事务
 * 			如果为true，告诉数据库此事务为只读事务，数据化优化，会对性能有一定提升，所以只要是查询的方法，建议使用此数据
 * 			如果为false(默认)事务需要提交的事务，建议新增，删除，修改
 * 		propagation 控制事务传播行为
 * 			当一个具体事务控制的方法被另一个有事务控制的方法调用后，需要如何管理事务(新增事务？在事务中执行？把事务挂起？包异常？)
 * 			REQUIRED(默认) 如果当前有事务，就在事务中执行，如果当前没有事务，新建一个事务
 * 			SUPPORTS:如果当前有事务就在事务中执行，如果当前没有事务，就在非事务状态下执行.
 * 			MANDATORY:必须在事务内部执行，如果当前有事务，就在事务中执行，如果没有事务，报错
 * 			REQUIRES_NEW:必须在事务中执行，如果当前没有事务，新建事务，如果当前有事务，把当前事务挂起.
 *  		NOT_SUPPORTED:必须在非事务下执行，如果当前没有事务，正常执行，如果当前有事务，把当前事务挂起.
 *   		NEVER:必须在非事务状态下执行，如果当前没有事务，正常执行，如果当前有事务，报错.
 *    		NESTED:必须在事务状态下执行，如果没有事务，新建事务，如果当前有事务，创建一个嵌套事务.
 *    	isolation=""事务隔离级别
 *    		在多线程或并发访问下如何保证访问到的数据具有完整性的
 *    		脏读：
 *    			一个事务A读取到另一个事务B中未提交的数据，另一个事务中数据可能进行了改变，此时A事务读取的数据可和数据库中数据不
 *    			一致，此时认为数据是脏数据，读取脏数据过程叫脏读
 *    		不可重复读：
 *    			主要针对的是某行数据(或行中某列)
 *    			主要针对的操作是修改操作
 *    			俩次读取在同一个事务内
 *    			当事务A第一次读取事务后，事务B对事务A读取的数据进行修改，事务A中再次读取的数据和之前的数据不一致，过程不可重复读
 *    		幻读：
 *    			主要针对的操作是新增或删除
 *    			俩次事务的结果
 *    			事务A按照特定条件查询出结果，事务B新增了一条符合条件的数据，事务A中查询的数据和数据库中的数据不一致，事务A好像出现了幻觉，这种情况称为幻读
 *     		DEFAULT: 默认值，由底层数据库自动判断应，该使用什么隔离界别
 *      	READ_UNCOMMITTED: 可以读取未提交数据可能出现脏读，不重复读，幻读
 *      		效率最高
 *       	READ_COMMITTED:只能读取其他事务已提交数据，可以防止脏读，可能出现不可重复读和幻读.
 *        	REPEATABLE_READ: 读取的数据被添加锁，防止其他事务修改此数据，可以防止不可重复读，脏读，可能出现幻读.
 *       	SERIALIZABLE: 排队操作，对整个表添加锁，一个事务在操作数据时，另一个事务等待事务操作完成后才能操作这个表.
 *       		最安全
 *       		效率最低的
 *       rollback-for="异常类型全限定路径"
 *       	当出现什么异常时需要进行回滚
 *       	建议：给定该属性值
 *       		手动抛异常一定要给该属性值
 *       no-rollbakc-for=""
 *       	当出现什么异常时不会滚事务
 * 
 * Spring 中常用注解
 * 		@Component 创建类对象，相当于配置<bean/>
 * 		@Service 与@Component 功能相同.
 * 			写在 ServiceImpl 类上.
 * 		@Repository 与@Component 功能相同
 * 			写在数据访问层类上.
 * 		@Controller 与@Component 功能相同.
 * 			写在控制器类上
 * 		@Resource(不需要写对象的 get/set)
 * 			java 中的注解
 * 			默认按照 byName 注入，如果没有名称对象，按照 byType 注入
 * 				建议把对象名称和 spring 容器中对象名相同
 * 		@Autowired(不需要写对象的 get/set）
 * 			spring 的注解
 * 			 默认按照 byType 注入
 * 		@Value() 获取 properties 文件中内容
 * 		@Pointcut() 定义切点
 * 		@Aspect() 定义切面类
 * 		@Before() 前置通知
 * 		@After 后置通知
 * 		@AfterReturning 后置通知,必须切点正确执行
 * 		@AfterThrowing 异常通知
 * 		@Arround 环绕通知
 * @author xujinshan361@163.com
 *
 */
public class Test {

}
